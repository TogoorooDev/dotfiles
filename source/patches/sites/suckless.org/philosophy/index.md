Philosophy
==========
We are the home of quality software such as [dwm](//dwm.suckless.org),
[dmenu](//tools.suckless.org/dmenu), [st](//st.suckless.org/) and plenty of
other [tools](//tools.suckless.org), with a focus on simplicity, clarity and
frugality. Our philosophy is about keeping things simple, minimal and usable.
We believe this should become the mainstream philosophy in the IT sector.
Unfortunately, the tendency for complex, error-prone and slow software seems to
be prevalent in the present-day software industry. We intend to prove the
opposite with our software projects.

Our project focuses on advanced and experienced computer users. In contrast
with the usual proprietary software world or many mainstream open source
projects that focus more on average and non-technical end users, we think that
experienced users are mostly ignored. This is particularly true for user
interfaces, such as graphical environments on desktop computers, on mobile
devices, and in so-called Web applications. We believe that the market of
experienced users is growing continuously, with each user looking for more
appropriate solutions for his/her work style.

Designing simple and elegant software is far more difficult than letting ad-hoc
or over-ambitious features obscure the code over time. However one has to pay
this price to achieve reliability and maintainability. Furthermore, minimalism
results in reasonable and attainable goals. We strive to maintain minimalism
and clarity to drive development to completion.

Manifest
--------
Many (open source) hackers are proud if they achieve large amounts of code,
because they believe the more lines of code they've written, the more progress
they have made. The more progress they have made, the more skilled they are.
This is simply a delusion.

Most hackers actually don't care much about code quality. Thus, if they get
something working which seems to solve a problem, they stick with it. If this
kind of software development is applied to the same source code throughout its
entire life-cycle, we're left with large amounts of code, a totally screwed
code structure, and a flawed system design. This is because of a lack of
conceptual clarity and integrity in the development process.

Code complexity is the mother of bloated, hard to use, and totally inconsistent
software. With complex code, problems are solved in suboptimal ways, valuable
resources are endlessly tied up, performance slows to a halt, and
vulnerabilities become a commonplace. The only solution is to scrap the entire
project and rewrite it from scratch.

The bad news: quality rewrites rarely happen, because hackers are proud of
large amounts of code. They think they understand the complexity in the code,
thus there's no need to rewrite it. They think of themselves as masterminds,
understanding what others can never hope to grasp. To these types, complex
software is the ideal.

Ingenious ideas are simple. Ingenious software is simple. Simplicity is the
heart of the Unix philosophy. The more code lines you have removed, the more
progress you have made. As the number of lines of code in your software
shrinks, the more skilled you have become and the less your software sucks.

Related links
-------------
* [The Duct Tape Programmer](http://www.joelonsoftware.com/items/2009/09/23.html)
* [Why should I have written ZeroMQ in C, not C++](http://www.250bpm.com/blog:4)
* [Best practices in application architecture: Use layers to decouple](http://geekandpoke.typepad.com/.a/6a00d8341d3df553ef014e5f920093970c-pi)
* [Facebook's code quality problem](http://www.darkcoding.net/software/facebooks-code-quality-problem/)
* [Minimal Viable Programs](http://joearms.github.io/published/2014-06-25-minimal-viable-program.html)
* [Why I Write Games in C](http://jonathanwhiting.com/writing/blog/games_in_c/)
* [Use of command-line tools for effective data processing](https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html)
